import sys
import os
import math

# The start symbol for the grammar
TOP = "TOP"

class Rule:
    ''' A grammatical Rule has a probability and a parent category, and is extended by UnaryRule and BinaryRule 

    Used to express CFG transition rules that have been converted to Chomsky Normal Form: 
    Let A, B, and C be nonterminals and w be a terminal. A CFG in Chomsky Normal Form only has two forms of rules:
    A -> B C 
    A -> w 

    The Rule class represents these transitions as a single Parent and a tuple of Children. The Parent is the 
    nonterminal on the LHS and the Child(ren) are the RHS. The Rule base class itself should not be initialized 
    (i.e., it is abstract). The A -> B C rule is represented using a BinaryRule object and the A -> w rule is represented 
    using a UnaryRule object. 
    '''
    
    def __init__(self, probability, parent):
        """ Initializes a Rule 

        Input: 
            probability: float, represents the rule probability
            parent: TBD
        Output: None 
        """
        self.prob = probability
        self.parent = parent

    @staticmethod
    def createRule(probability, parent, childList):
        """ Factory method for making unary or binary rules (returns None otherwise) """
        if len(childList) == 1:
            return UnaryRule(probability, parent, childList[0])
        elif len(childList) == 2:
            return BinaryRule(probability, parent, childList[0], childList[1])
        return None

    def children(self):
        """ Returns a tuple containing the rule's children. In the Rule base class, this returns an empty tuple. """
        return ()

class UnaryRule(Rule):
    """ Represents rules of the form A -> w """

    def __init__(self, probability, parent, child):
        """ Initializes a UnaryRule object 

        parent and child are of type string and prob is of type float.
        """ 
        Rule.__init__(self, probability, parent)
        self.child = child

    def __str__(self): 
        """ Allows this class to be printed """
        return "{} {} -> {}" .format(math.exp(self.prob), self.parent, self.child)

    def children(self):
        """ Returns a singleton (tuple) containing the rule's child """ 
        return (self.child,)  # note the comma; (self.child) is not a tuple, it's a set 

class BinaryRule(Rule):
    """ Represents rules of the form A -> B C """

    def __init__(self, probability, parent, leftChild, rightChild):
        """ Initializes a BinaryRule object 
        
        parent, leftChild, and rightChild are all of type string. prob is of type float.
        """
        Rule.__init__(self, probability, parent)
        self.leftChild = leftChild
        self.rightChild = rightChild

    def __str__(self): 
        """ Allows this class to be printed """
        return "{} {} -> {} {}".format(math.exp(self.prob), self.parent, self.leftChild, self.rightChild)
        
    def children(self):
        """ Returns a pair (tuple) containing the rule's children """
        return (self.leftChild, self.rightChild)

class Item:
    """ An Item stores the label and Viterbi probability for a node in a parse tree. This class should not 
    actually be initialized (i.e., it is abstract) - use InternalItem and LeafItem """ 

    def __init__(self, label, prob, numParses):
        """ Initializes an Item 
        
        Types: 
        self.label: string 
        self.prob: float 
        self.numParses: int 
        """
        self.label = label
        self.prob = prob
        self.numParses = numParses

    def __str__(self):
        """ Allows Item objects to be printed """ 
        return self.toString()

    def toString(self):
        """ Returns the node's label """
        return self.label

class LeafItem(Item):
    """ A LeafItem is an Item that represents a leaf (word) in the parse tree (i.e., it doesn't have children, 
    and it has a Viterbi probability of 1.0) """ 
    
    def __init__(self, word):
        # using log probabilities, this is the default value (0.0 = log(1.0))
        Item.__init__(self, word, 0.0, 1)

class InternalItem(Item):
    """ An InternalNode stores an internal node in a parse tree (ie, it also stores pointers to the node's child[ren]) 

    The children nodes should also be of type Item. It is possible to only have one child (if this node was generated 
    by a UnaryRule) or to have two children (if this node was generated by a BinaryRule).
    """ 
    
    def __init__(self, category, prob, numParses, children=()):
        """ Initializes an InternalItem object

        Category should be equal to the LHS of a CFG rule. i.e., pass in the parent attribute in a rule object 
        """ 
        Item.__init__(self, category, prob, 0)
        self.children = children
        # Your task is to update the number of parses for this InternalItem
        # to reflect how many possible parses are rooted at this label
        # for the string spanned by this item in a chart
        self.numParses = numParses  # dummy numParses value; this should not be -1!
        if len(self.children) > 2:
            print("Warning: adding a node with more than two children (CKY may not work correctly)")

    def __str__(self): 
        """ Allows InternalItem objects to be printed """
        return self.toString()

    # For an internal node, we want to recurse through the labels of the
    # subtree rooted at this node
    def toString(self):
        ret = "( " + self.label + " "
        for child in self.children:
            ret += child.toString() + " "
        return ret + ")"

class Cell:
    """ 
    Cell represents a cell in the Upper Triangular CKY chart. It contains all of the parse trees that share a common span of a 
    subset of the words in a sentence. It also contains a list of backpointer tuples.
    """ 
    def __init__(self):
        self.items = {}
        self.backpointers = []

    def __str__(self): 
        """ Allows Cell objects to be printed """ 
        out = "" 
        for label, items in self.items.items(): 
            for item in items: 
                out += "{}, {}\t".format(label, item)
        return out

    def addItem(self, item):
        if item in self.items.keys(): 
            self.items[item.label].append(item)
        else: 
            self.items[item.label] = [item]

    def getItem(self, label):
        if len(self.items) == 0: 
            return None
        return self.items[label]

    def getItems(self):
        if len(self.items) == 0: 
            return None 
        return self.items 

    def getBestItem(self): 
        if len(self.items) == 0: 
            return None 
        bestItem = Item("", -math.inf, 0)
        for labels, items in self.items.items(): 
            for item in items: 
                if item.prob > bestItem.prob: 
                    bestItem = item
        return bestItem

    @staticmethod
    def calculateNumParses(cell): 
        if len(cell.backpointers) == 0:
            return 1
        total = 0 
        for backpointer in cell.backpointers: 
            left = Cell.calculateNumParses(backpointer[0])
            right = Cell.calculateNumParses(backpointer[1])
            total += left * right 
        return total

class Chart:
    """ 
    Chart represents the Upper Triangular portion of an NxN matrix, where N is equal to the length of the input sentence 

    Since we are only interested in the upper triangular, the data is represented using a nested dictionary rather than 
    a statically sized array. The data is thus organized: {i: {j: Cell}} such that Chart[i][j] returns an object of type Cell.
    Note that j should range between [i, N] and i should range between [1, N]. The Cell at Chart[i][j] contains the parse 
    trees that correspond to the span of sentence[i : j], inclusive on both bounds and with indexing starting at 1. 
    
    e.g., Let sentence = "the man eats the tuna with a fork". 
    Then Chart[2][4] gets the parse trees corresponding to "man eats the". 
    """ 
    def __init__(self, sentence):
        """ Initializes the Chart used for the CKY Algorithm

        Input:
        sentence: a list of strings 
        """ 
        self.N = len(sentence) 
        self.cells = dict() 
        for i in range(self.N): 
            self.cells[i + 1] = dict() 
            for j in range(i, self.N + 1): 
                self.cells[i + 1][j] = Cell() 

    def __str__(self): 
        """ Allows Chart objects to be printed """ 
        out = "" 
        for row in self.cells.keys(): 
            for column, cell in self.cells[row].items(): 
                out += "({}, {}): {}\n".format(row, column, str(cell))
        return out

    def getRoot(self):
        """ Returns the InternalItem contained in the root cell of the chart """
        # return self.cells[self.N - 1][self.N - 1].getMaxItem() # Need to write this method
        return self.cells[1][self.N].getBestItem()

    def getCell(self, i, j):
        """ Returns the Cell object at position i, j """ 
        return self.cells[i][j]

class PCFG:
    """ A representation of a Probabilistic Context-Free Grammar that can be used to produce the most likely parse for 
    an input sentence (if one exists)

    The rules themselves are contained in the dictionary ckyRules, which maps from tuples of children to a list of 
    rules that produce said children 
    """ 
    def __init__(self, grammarFile, debug=False):
        """ Initializes a PCFG 

        ckyRules is a dictionary that maps from a rule's RHS (i.e., the children, stored in a tuple) to a list of Rule objects 
        that contain the children as their RHS. The Rule objects encapsulate the LHS (parent), the RHS (children), and the rule 
        probabilities 
        """ 
        self.ckyRules = {}
        self.debug = debug                  # boolean flag for debugging
        self.readGrammar(grammarFile)
        self.topCheck() # checks that the grammar at least matches the start symbol defined at the beginning of this file (TOP)

    def printCKYRules(self): 
        """ Displays the PCFG rules that we've generated by parsing the given grammar file """
        if len(self.ckyRules) == 0: 
            print("Grammar file has not been parsed yet")
            return 
        out = "" 
        for child, rules in self.ckyRules.items(): 
            for rule in rules: 
                out += "{}: {}\n".format(child, str(rule))
        print(out)

    def readGrammar(self, grammarFile):
        """ Reads the rules for this grammar from an input file """ 
        if os.path.isfile(grammarFile):
            file = open(grammarFile, "r")
            for line in file:
                raw = line.split()
                # reminder, we're using log probabilities
                prob = math.log(float(raw[0]))
                parent = raw[1]
                children = raw[
                    3:]   # Note: here, children is a list; below, rule.children() is a tuple
                rule = Rule.createRule(prob, parent, children)
                if rule.children() not in self.ckyRules:
                    self.ckyRules[rule.children()] = set()
                self.ckyRules[rule.children()].add(rule)

    def topCheck(self):
        """ Checks that the grammar at least matches the start symbol (TOP) by passing over every Rule object contained in self.ckyRules """ 
        for rules in self.ckyRules.values(): # Lists of Rule objects 
            for rule in rules: # Rule object
                if rule.parent == TOP:
                    return 
        if self.debug: 
            print("Warning: TOP symbol does not generate any children (grammar will always fail)")

    def CKY(self, sentence):
        """ Implements the CKY Algorithm. See the PCFG Jupyter Notebook for implementation details """ 
        # Initializing the Upper Triangular Matrix 
        chart = Chart(sentence)

        # Initializing the cells along [i, 0] for LeafItems
        for i in range(chart.N): # j = i 
            word = sentence[i] 
            cell = chart.getCell(i + 1, i)
            item = LeafItem(word) 
            cell.addItem(item)

        # Initializing the cells along the main diagonal: [i, i]
        for i in range(chart.N): 
            word = sentence[i]
            leafItem = chart.getCell(i + 1, i).getItem(word) # Returns a LeafItem 
            diag = chart.getCell(i + 1, i + 1)
            label = (word, )
            if label not in self.ckyRules.keys(): 
                internalItem = InternalItem(word, 1, 1) # No children
                diag.addItem(internalItem)
            else: 
                rules = self.ckyRules[label]
                for rule in rules: 
                    internalItem = InternalItem(rule.parent, rule.prob, 1, leafItem) 
                    diag.addItem(internalItem) 

        # Dynamic Programming 
        offset = 1
        while offset < chart.N: 
            for i in range(1, chart.N): 
                j = i + offset 
                if j > chart.N: 
                    continue
                cell = chart.getCell(i, j)
                for k in range(i, j):
                    leftCell = chart.getCell(i, k)
                    rightCell = chart.getCell(k + 1, j)
                    leftRule = leftCell.getBestItem()
                    rightRule = rightCell.getBestItem()
                    if leftRule == None or rightRule == None: 
                        continue
                    label = (leftRule.label, rightRule.label)
                    if label not in self.ckyRules.keys(): 
                        continue 
                    else: 
                        rules = self.ckyRules[label] # A list of Rule objects 
                        for rule in rules: 
                            internalItem = InternalItem(rule.parent, rule.prob + leftRule.prob + rightRule.prob, 1, (leftRule, rightRule)) 
                            cell.addItem(internalItem)
                            cell.backpointers.append((leftCell, rightCell))
            offset += 1

        # Output 
        root = chart.getRoot() 
        if root == None: 
            return None
        rootCell = chart.getCell(1, chart.N)
        numParses = Cell.calculateNumParses(rootCell)
        top = InternalItem("TOP", root.prob, numParses, (root,))
        return top

if __name__ == "__main__":
    pcfg = PCFG('toygrammar.pcfg')
    sen = "the man eats the tuna with a fork and some sushi with the chopsticks".split()

    tree = pcfg.CKY(sen)
    if tree is not None:
        print(tree.toString())
        print("Probability: " + str(math.exp(tree.prob)))
        print("Num parses: " + str(tree.numParses))
    else:
        print("Parse failure!")